// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package payload

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type Valor byte

const (
	ValorNONE       Valor = 0
	ValorValorFloat Valor = 1
	ValorValorBool  Valor = 2
)

var EnumNamesValor = map[Valor]string{
	ValorNONE:       "NONE",
	ValorValorFloat: "ValorFloat",
	ValorValorBool:  "ValorBool",
}

var EnumValuesValor = map[string]Valor{
	"NONE":       ValorNONE,
	"ValorFloat": ValorValorFloat,
	"ValorBool":  ValorValorBool,
}

func (v Valor) String() string {
	if s, ok := EnumNamesValor[v]; ok {
		return s
	}
	return "Valor(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ValorFloat struct {
	_tab flatbuffers.Table
}

func GetRootAsValorFloat(buf []byte, offset flatbuffers.UOffsetT) *ValorFloat {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ValorFloat{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsValorFloat(buf []byte, offset flatbuffers.UOffsetT) *ValorFloat {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ValorFloat{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ValorFloat) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ValorFloat) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ValorFloat) Valor() float32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat32(o + rcv._tab.Pos)
	}
	return 0.0
}

func (rcv *ValorFloat) MutateValor(n float32) bool {
	return rcv._tab.MutateFloat32Slot(4, n)
}

func ValorFloatStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ValorFloatAddValor(builder *flatbuffers.Builder, valor float32) {
	builder.PrependFloat32Slot(0, valor, 0.0)
}
func ValorFloatEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ValorBool struct {
	_tab flatbuffers.Table
}

func GetRootAsValorBool(buf []byte, offset flatbuffers.UOffsetT) *ValorBool {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ValorBool{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsValorBool(buf []byte, offset flatbuffers.UOffsetT) *ValorBool {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ValorBool{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ValorBool) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ValorBool) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ValorBool) Valor() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *ValorBool) MutateValor(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

func ValorBoolStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func ValorBoolAddValor(builder *flatbuffers.Builder, valor bool) {
	builder.PrependBoolSlot(0, valor, false)
}
func ValorBoolEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type ClaveValor struct {
	_tab flatbuffers.Table
}

func GetRootAsClaveValor(buf []byte, offset flatbuffers.UOffsetT) *ClaveValor {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ClaveValor{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsClaveValor(buf []byte, offset flatbuffers.UOffsetT) *ClaveValor {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ClaveValor{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ClaveValor) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ClaveValor) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ClaveValor) Clave() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ClaveValor) ValorType() Valor {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Valor(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ClaveValor) MutateValorType(n Valor) bool {
	return rcv._tab.MutateByteSlot(6, byte(n))
}

func (rcv *ClaveValor) Valor(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ClaveValorStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ClaveValorAddClave(builder *flatbuffers.Builder, clave flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(clave), 0)
}
func ClaveValorAddValorType(builder *flatbuffers.Builder, valorType Valor) {
	builder.PrependByteSlot(1, byte(valorType), 0)
}
func ClaveValorAddValor(builder *flatbuffers.Builder, valor flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(valor), 0)
}
func ClaveValorEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
type Payload struct {
	_tab flatbuffers.Table
}

func GetRootAsPayload(buf []byte, offset flatbuffers.UOffsetT) *Payload {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Payload{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsPayload(buf []byte, offset flatbuffers.UOffsetT) *Payload {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Payload{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Payload) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Payload) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Payload) Id(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *Payload) IdLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Payload) IdBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Payload) MutateId(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *Payload) Valores(obj *ClaveValor, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Payload) ValoresLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Payload) Timestamp() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *Payload) MutateTimestamp(n int64) bool {
	return rcv._tab.MutateInt64Slot(8, n)
}

func PayloadStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func PayloadAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0)
}
func PayloadStartIdVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func PayloadAddValores(builder *flatbuffers.Builder, valores flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(valores), 0)
}
func PayloadStartValoresVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func PayloadAddTimestamp(builder *flatbuffers.Builder, timestamp int64) {
	builder.PrependInt64Slot(2, timestamp, 0)
}
func PayloadEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
